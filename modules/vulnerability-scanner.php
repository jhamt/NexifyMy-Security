<?php
/**
 * Vulnerability Scanner Module.
 * Scans plugins, themes, and core for known vulnerabilities.
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

class NexifyMy_Security_Vulnerability_Scanner {

	/**
	 * WPScan API endpoint.
	 */
	const WPSCAN_API_URL = 'https://wpscan.com/api/v3/';

	/**
	 * Cache expiry in seconds (12 hours).
	 */
	const CACHE_EXPIRY = 43200;

	/**
	 * Default settings.
	 */
	private static $defaults = array(
		'enabled'          => true,
		'auto_scan'        => false,
		'scan_schedule'    => 'weekly',
		'email_alerts'     => true,
		'wpscan_api_token' => '',
	);

	/**
	 * Initialize the module.
	 */
	public function init() {
		// Schedule automatic scans.
		add_action( 'nexifymy_vulnerability_scan', array( $this, 'run_scheduled_scan' ) );

		if ( ! wp_next_scheduled( 'nexifymy_vulnerability_scan' ) ) {
			$settings = $this->get_settings();
			if ( ! empty( $settings['auto_scan'] ) ) {
				$schedule = $settings['scan_schedule'] === 'daily' ? 'daily' : 'weekly';
				wp_schedule_event( time(), $schedule, 'nexifymy_vulnerability_scan' );
			}
		}

		// AJAX handlers.
		add_action( 'wp_ajax_nexifymy_run_vulnerability_scan', array( $this, 'ajax_run_scan' ) );
		add_action( 'wp_ajax_nexifymy_get_vulnerability_results', array( $this, 'ajax_get_results' ) );
		add_action( 'wp_ajax_nexifymy_save_vuln_settings', array( $this, 'ajax_save_settings' ) );
	}

	/**
	 * Get module settings.
	 *
	 * @return array
	 */
	public function get_settings() {
		if ( class_exists( 'NexifyMy_Security_Settings' ) ) {
			$all_settings = NexifyMy_Security_Settings::get_all();
			if ( isset( $all_settings['vulnerability'] ) ) {
				return wp_parse_args( $all_settings['vulnerability'], self::$defaults );
			}
		}
		return self::$defaults;
	}

	/**
	 * Run a full vulnerability scan.
	 *
	 * @return array Scan results.
	 */
	public function run_scan() {
		$results = array(
			'scan_time'        => current_time( 'mysql' ),
			'core'             => $this->check_core_version(),
			'plugins'          => $this->check_plugins(),
			'themes'           => $this->check_themes(),
			'vulnerable_count' => 0,
			'outdated_count'   => 0,
		);

		// Count vulnerabilities.
		if ( ! empty( $results['core']['vulnerable'] ) ) {
			++$results['vulnerable_count'];
			do_action(
				'nexifymy_vulnerability_found',
				array(
					'type'            => 'core',
					'component'       => 'wordpress',
					'current_version' => $results['core']['current'] ?? '',
					'latest_version'  => $results['core']['latest'] ?? '',
					'details'         => $results['core']['vulnerable'],
				)
			);
		}
		if ( $results['core']['outdated'] ) {
			++$results['outdated_count'];
		}

		foreach ( $results['plugins'] as $slug => $plugin ) {
			if ( ! empty( $plugin['vulnerable'] ) ) {
				++$results['vulnerable_count'];
				do_action(
					'nexifymy_vulnerability_found',
					array(
						'type'            => 'plugin',
						'plugin'          => $slug,
						'component'       => $plugin['name'] ?? $slug,
						'current_version' => $plugin['version'] ?? '',
						'latest_version'  => $plugin['latest'] ?? '',
						'details'         => $plugin['vulnerable'],
					)
				);
			}
			if ( $plugin['outdated'] ) {
				++$results['outdated_count'];
			}
		}

		foreach ( $results['themes'] as $slug => $theme ) {
			if ( ! empty( $theme['vulnerable'] ) ) {
				++$results['vulnerable_count'];
				do_action(
					'nexifymy_vulnerability_found',
					array(
						'type'            => 'theme',
						'theme'           => $slug,
						'component'       => $theme['name'] ?? $slug,
						'current_version' => $theme['version'] ?? '',
						'latest_version'  => $theme['latest'] ?? '',
						'details'         => $theme['vulnerable'],
					)
				);
			}
			if ( $theme['outdated'] ) {
				++$results['outdated_count'];
			}
		}

		// Cache results.
		set_transient( 'nexifymy_vulnerability_scan', $results, self::CACHE_EXPIRY );

		// Log the scan.
		if ( class_exists( 'NexifyMy_Security_Logger' ) ) {
			$severity = $results['vulnerable_count'] > 0 ? 'warning' : 'info';
			NexifyMy_Security_Logger::log(
				'vulnerability_scan',
				sprintf( 'Scan complete: %d vulnerabilities, %d outdated', $results['vulnerable_count'], $results['outdated_count'] ),
				$severity,
				array(
					'vulnerable' => $results['vulnerable_count'],
					'outdated'   => $results['outdated_count'],
				)
			);
		}

		return $results;
	}

	/**
	 * Check WordPress core version.
	 *
	 * @return array Core status.
	 */
	private function check_core_version() {
		global $wp_version;

		$latest = $this->get_latest_wp_version();

		return array(
			'current'    => $wp_version,
			'latest'     => $latest,
			'outdated'   => version_compare( $wp_version, $latest, '<' ),
			'vulnerable' => $this->check_core_vulnerabilities( $wp_version ),
		);
	}

	/**
	 * Get latest WordPress version.
	 *
	 * @return string
	 */
	private function get_latest_wp_version() {
		$cached = get_transient( 'nexifymy_latest_wp_version' );
		if ( $cached ) {
			return $cached;
		}

		$response = wp_remote_get( 'https://api.wordpress.org/core/version-check/1.7/', array( 'timeout' => 10 ) );

		if ( is_wp_error( $response ) ) {
			global $wp_version;
			return $wp_version;
		}

		$body = json_decode( wp_remote_retrieve_body( $response ), true );

		if ( isset( $body['offers'][0]['version'] ) ) {
			$version = $body['offers'][0]['version'];
			set_transient( 'nexifymy_latest_wp_version', $version, DAY_IN_SECONDS );
			return $version;
		}

		global $wp_version;
		return $wp_version;
	}

	/**
	 * Check core for known vulnerabilities.
	 *
	 * @param string $version WordPress version.
	 * @return array|false Vulnerabilities or false.
	 */
	private function check_core_vulnerabilities( $version ) {
		$settings = $this->get_settings();

		if ( empty( $settings['wpscan_api_token'] ) ) {
			return false;
		}

		$response = wp_remote_get(
			self::WPSCAN_API_URL . 'wordpresses/' . str_replace( '.', '', $version ),
			array(
				'headers' => array( 'Authorization' => 'Token token=' . $settings['wpscan_api_token'] ),
				'timeout' => 15,
			)
		);

		if ( is_wp_error( $response ) ) {
			return false;
		}

		$data = json_decode( wp_remote_retrieve_body( $response ), true );

		if ( isset( $data[ str_replace( '.', '', $version ) ]['vulnerabilities'] ) ) {
			return $data[ str_replace( '.', '', $version ) ]['vulnerabilities'];
		}

		return false;
	}

	/**
	 * Check all plugins for vulnerabilities.
	 *
	 * @return array Plugin scan results.
	 */
	private function check_plugins() {
		if ( ! function_exists( 'get_plugins' ) ) {
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		}

		$plugins = get_plugins();
		$updates = get_site_transient( 'update_plugins' );
		$results = array();

		foreach ( $plugins as $file => $data ) {
			$slug = dirname( $file );
			if ( '.' === $slug ) {
				$slug = basename( $file, '.php' );
			}

			$has_update = isset( $updates->response[ $file ] );

			$results[ $slug ] = array(
				'name'       => $data['Name'],
				'version'    => $data['Version'],
				'latest'     => $has_update ? $updates->response[ $file ]->new_version : $data['Version'],
				'outdated'   => $has_update,
				'vulnerable' => $this->check_plugin_vulnerabilities( $slug, $data['Version'] ),
				'active'     => is_plugin_active( $file ),
			);
		}

		return $results;
	}

	/**
	 * Check plugin for vulnerabilities.
	 *
	 * @param string $slug Plugin slug.
	 * @param string $version Plugin version.
	 * @return array|false
	 */
	private function check_plugin_vulnerabilities( $slug, $version ) {
		$settings = $this->get_settings();

		if ( empty( $settings['wpscan_api_token'] ) ) {
			return false;
		}

		$cache_key = 'nexifymy_vuln_plugin_' . md5( $slug . $version );
		$cached    = get_transient( $cache_key );

		if ( false !== $cached ) {
			return $cached;
		}

		$response = wp_remote_get(
			self::WPSCAN_API_URL . 'plugins/' . $slug,
			array(
				'headers' => array( 'Authorization' => 'Token token=' . $settings['wpscan_api_token'] ),
				'timeout' => 15,
			)
		);

		if ( is_wp_error( $response ) ) {
			return false;
		}

		$data = json_decode( wp_remote_retrieve_body( $response ), true );

		$vulnerabilities = array();
		if ( isset( $data[ $slug ]['vulnerabilities'] ) ) {
			foreach ( $data[ $slug ]['vulnerabilities'] as $vuln ) {
				// Check if vulnerability affects current version.
				if ( isset( $vuln['fixed_in'] ) && version_compare( $version, $vuln['fixed_in'], '<' ) ) {
					$vulnerabilities[] = $vuln;
				} elseif ( ! isset( $vuln['fixed_in'] ) ) {
					$vulnerabilities[] = $vuln;
				}
			}
		}

		$result = empty( $vulnerabilities ) ? false : $vulnerabilities;
		set_transient( $cache_key, $result, self::CACHE_EXPIRY );

		return $result;
	}

	/**
	 * Check all themes for vulnerabilities.
	 *
	 * @return array Theme scan results.
	 */
	private function check_themes() {
		$themes        = wp_get_themes();
		$updates       = get_site_transient( 'update_themes' );
		$current_theme = get_stylesheet();
		$results       = array();

		foreach ( $themes as $slug => $theme ) {
			$has_update = isset( $updates->response[ $slug ] );

			$results[ $slug ] = array(
				'name'       => $theme->get( 'Name' ),
				'version'    => $theme->get( 'Version' ),
				'latest'     => $has_update ? $updates->response[ $slug ]['new_version'] : $theme->get( 'Version' ),
				'outdated'   => $has_update,
				'vulnerable' => $this->check_theme_vulnerabilities( $slug, $theme->get( 'Version' ) ),
				'active'     => $slug === $current_theme,
			);
		}

		return $results;
	}

	/**
	 * Check theme for vulnerabilities.
	 *
	 * @param string $slug Theme slug.
	 * @param string $version Theme version.
	 * @return array|false
	 */
	private function check_theme_vulnerabilities( $slug, $version ) {
		$settings = $this->get_settings();

		if ( empty( $settings['wpscan_api_token'] ) ) {
			return false;
		}

		$cache_key = 'nexifymy_vuln_theme_' . md5( $slug . $version );
		$cached    = get_transient( $cache_key );

		if ( false !== $cached ) {
			return $cached;
		}

		$response = wp_remote_get(
			self::WPSCAN_API_URL . 'themes/' . $slug,
			array(
				'headers' => array( 'Authorization' => 'Token token=' . $settings['wpscan_api_token'] ),
				'timeout' => 15,
			)
		);

		if ( is_wp_error( $response ) ) {
			return false;
		}

		$data = json_decode( wp_remote_retrieve_body( $response ), true );

		$vulnerabilities = array();
		if ( isset( $data[ $slug ]['vulnerabilities'] ) ) {
			foreach ( $data[ $slug ]['vulnerabilities'] as $vuln ) {
				if ( isset( $vuln['fixed_in'] ) && version_compare( $version, $vuln['fixed_in'], '<' ) ) {
					$vulnerabilities[] = $vuln;
				} elseif ( ! isset( $vuln['fixed_in'] ) ) {
					$vulnerabilities[] = $vuln;
				}
			}
		}

		$result = empty( $vulnerabilities ) ? false : $vulnerabilities;
		set_transient( $cache_key, $result, self::CACHE_EXPIRY );

		return $result;
	}

	/**
	 * Run scheduled scan.
	 */
	public function run_scheduled_scan() {
		$settings = $this->get_settings();

		if ( empty( $settings['enabled'] ) || empty( $settings['auto_scan'] ) ) {
			return;
		}

		$results = $this->run_scan();

		// Send email alert if vulnerabilities found.
		if ( ! empty( $settings['email_alerts'] ) && $results['vulnerable_count'] > 0 ) {
			$this->send_alert_email( $results );
		}
	}

	/**
	 * Send vulnerability alert email.
	 *
	 * @param array $results Scan results.
	 */
	private function send_alert_email( $results ) {
		$to      = get_option( 'admin_email' );
		$subject = sprintf( '[%s] Vulnerability Alert: %d issues found', get_bloginfo( 'name' ), $results['vulnerable_count'] );

		$message  = "A vulnerability scan has detected security issues on your site.\n\n";
		$message .= "Vulnerable items: {$results['vulnerable_count']}\n";
		$message .= "Outdated items: {$results['outdated_count']}\n\n";
		$message .= "Please log in to your WordPress admin to review and update affected items.\n";
		$message .= admin_url( 'admin.php?page=nexifymy-security-vulnerabilities' );

		wp_mail( $to, $subject, $message );
	}

	/**
	 * Get cached scan results.
	 *
	 * @return array|false
	 */
	public function get_cached_results() {
		return get_transient( 'nexifymy_vulnerability_scan' );
	}

	/*
	 * =========================================================================
	 * AJAX HANDLERS
	 * =========================================================================
	 */

	/**
	 * Run scan via AJAX.
	 */
	public function ajax_run_scan() {
		check_ajax_referer( 'nexifymy_security_nonce', 'nonce' );

		if ( ! current_user_can( 'manage_options' ) ) {
			wp_send_json_error( 'Unauthorized' );
		}

		$results = $this->run_scan();
		wp_send_json_success( array( 'results' => $results ) );
	}

	/**
	 * Get scan results via AJAX.
	 */
	public function ajax_get_results() {
		check_ajax_referer( 'nexifymy_security_nonce', 'nonce' );

		if ( ! current_user_can( 'manage_options' ) ) {
			wp_send_json_error( 'Unauthorized' );
		}

		$results = $this->get_cached_results();
		wp_send_json_success( array( 'results' => $results ? $results : null ) );
	}

	/**
	 * Save settings via AJAX.
	 */
	public function ajax_save_settings() {
		check_ajax_referer( 'nexifymy_security_nonce', 'nonce' );

		if ( ! current_user_can( 'manage_options' ) ) {
			wp_send_json_error( 'Unauthorized' );
		}

		$scan_schedule = isset( $_POST['scan_schedule'] ) ? sanitize_key( wp_unslash( $_POST['scan_schedule'] ) ) : 'weekly';

		$settings = array(
			'enabled'          => ! empty( $_POST['enabled'] ),
			'auto_scan'        => ! empty( $_POST['auto_scan'] ),
			'scan_schedule'    => in_array( $scan_schedule, array( 'daily', 'weekly' ), true ) ? $scan_schedule : 'weekly',
			'email_alerts'     => ! empty( $_POST['email_alerts'] ),
			'wpscan_api_token' => isset( $_POST['wpscan_api_token'] ) ? sanitize_text_field( wp_unslash( $_POST['wpscan_api_token'] ) ) : '',
		);
		if ( class_exists( 'NexifyMy_Security_Settings' ) ) {
			$all_settings                  = NexifyMy_Security_Settings::get_all();
			$all_settings['vulnerability'] = $settings;
			update_option( 'nexifymy_security_settings', $all_settings );
		}

		// Reschedule cron.
		wp_clear_scheduled_hook( 'nexifymy_vulnerability_scan' );
		if ( ! empty( $settings['auto_scan'] ) ) {
			$schedule = $settings['scan_schedule'] === 'daily' ? 'daily' : 'weekly';
			wp_schedule_event( time(), $schedule, 'nexifymy_vulnerability_scan' );
		}

		wp_send_json_success( array( 'message' => 'Settings saved.' ) );
	}
}
